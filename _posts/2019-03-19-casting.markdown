---
date: '2019-03-18 20:58:18 +0300'
layout: post
categories: jekyll update
---

Приведение типов.
=================

 

Приведение типов подразделяют на две группы: явное (выполняет программист) и
неявное (выполняет компилятор).

![](C:\Users\olya-\Desktop\git\olya-lem.github.io_posts\casting_paint.PNG)

**Неявное приведение (Promotion)**:

-   не требует оператора;

-   выполняется автоматически при копировании значения на совместимый тип: с
    повышением или потерей точности.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cpp
int a = 312;
short int b = a;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Преобразования, подразумевающие различную интерпретацию, требуют **явного
приведения**.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cpp
short a = 200;
int b;
b = (int) a; //C-style cating
b = int (a); //functional casting
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**С-стиль приведения типов доступен и в С++**, но считается не самодостаточным
(не так точен и заметен). Может быть использован для приведения  типа в  другой,
независимо от безопасности (без какой-либо проверки).

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
qDebug() << (double)13 / 7;     //1.85714
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Для более **безопасного и управляемого приведения типов в С++** были введены
следующие операторы:

-   **const_cast** – меняет спецификаторы ( cv qualifiers: const, volatile).
    Если не удалось – ошибка при компиляции. При использовании остальных
    приведений спецификаторы остаются.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cpp
int i;
const int* pi = &i;
int *j = const_cast<int*>(pi);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   **static_cast** – используется для приведения родственных встроенных типов
    (встроенные правила приведения) и не полиморфных классов.

Можно использовать:

для приведения указателей, если один из них является void\*;

для приведения между объектами классов, если один из них является наследником
другого (обычно исп. dynamic_cast).

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cpp
double a = 3.1415;
qDebug() << static_cast<int>(a);

double *b = &a;
qDebug() << static_cast<void*>(b);

void* c;
double* d = static_cast<double*>(b);

int e = 312;
short int f = e;

qDebug() << static_cast<int>(f);
qDebug() << static_cast<int*>(f); //нет связи между указателями

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-   **dynamic_cast** – безопасное приведение по иерархии наследования (включая
    виртуальное). Результат – полный объект запрашиваемого класса.

Использует RTTI чтобы привести указатель на объект одного класса к указателю на
объект другого класса (ссылки).

Классы должны быть **полиморфными** (в базовом классе – хотя бы одна виртуальная
функция, иначе – ошибка).

При невозможности приведения (известно только при выполнении) вернет 0.

Исключение – std::bad_cast.

\`\`\`cpp

class Base{};

class SubClass1 :public Base{};

class SubClass2 :public Base {};



Base\\\* obj1;

SubClass1\\\* obj_sub1;

dynamic_cast\\\<Base\\\*\\\> (obj_sub1);

dynamic_cast\\\<SubClass2\\\>(obj_sub1); // ошибка

\`\`\`

-   **reinterpret_cast** – самый опасный; результат может быть некорректным (нет
    проверок). Используется для приведения несвязанных типов.  Результат –
    двоичная копия.

Значение к значению не может быть приведено. Может быть использован для
приведения: указатель – указатель (несовместные), указатель – целое, целое –
указатель. Также со ссылками.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int a = 321;
double b = 344433;
int c = reinterpret_cast<int> (b); //ошибка
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int a = 321;
int* aa = &a;
long int b = a;
long int* bb = &b;
qDebug() << reinterpret_cast<int*> (*bb);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int a = 321;
int* aa = &a;
qDebug() << reinterpret_cast<int> (aa);
qDebug() << reinterpret_cast<int*> (a);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

Пример:

![](ex.png)

Отличие – проверка на принадлежность объекта, на который ссылается А, классу В.
Для проверки исп. информация о типах времени выполнения(RTTI), поведение которой
через границы разделяемых библиотек не регламентировано.

QT предоставляет свое средство для этой цели - qobject_cast. Он является
аналогом dynamic_cast (С++) для подклассов QObject (для остальных – не
определен). Не зависит от RTTI и может работать через границы разделяемых
библиотек.

Динамические приведения для своей работы требуют дополнительную информацию,
связанную с экземплярами объектов. Для dynamic_cast компилятор автоматически
связывает ее с таблицей виртуальных методов.

 

 
